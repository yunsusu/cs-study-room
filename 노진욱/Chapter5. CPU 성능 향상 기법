https://luxuriant-tibia-a88.notion.site/Chapter5-CPU-65840c193de54e4a92884bc1fb3f88a3?pvs=4
# Chapter5. CPU 성능 향상 기법

## **요약**

- 클럭 속도가 높을수록 CPU의 명령어 사이클은 더 빠르게 반복된다
- 코어란 CPU 내에서 명령어를 실행하는 부품으로 프로세스 안에 여러개가 있다
- 멀티코어(multi-core) CPU: 코어를 여러 개 포함하고 있는 CPU로 멀티코어 프로세서라고도 불림
- 멀티스레드(multithread) 프로세서: 하나의 코어로 여러 명령어를 동시에 처리하는 CPU로 멀티스레드 CPU로도 불림. ( **하드웨어 스레드를 여러개 가진다**)

# 1. 빠른 CPU를 위한 설계 기법

### 클럭

컴퓨터 부품들은 "클럭 신호" 주기에 맞춰서 명령어들이 실행되며 동작한다.

CPU는 ‘명령어 사이클’이라는 정해진 흐름에 맞춰 명령어를 실행한다.

- 즉, 클럭 속도가 높을수록 CPU의 명령어 사이클은 더 빠르게 반복된다.
- 따라서 클럭 속도가 높은 CPU가 성능이 일반적으로 좋으며, CPU의 속도 단위로 간주된다.

### 1) 클럭 속도

- 클럭 신호에 따라 CPU 명령어 사이클 및 컴퓨터 부품 동작
- 클럭속도는 일정하지 않음. 고성능을 요할 때는 클럭 속도를 높이고, 유연하게 낮추기도 함
- 클럭 속도 : 1초에 반복되는 클럭 획수(hZ 단위)
    - 1Hz는 1초에 클럭이 1번 반복된 것을 의미
- 오버클럭킹 : 최대 클럭 속도를 강제로 끌어올려서 CPU 성능을 향상시키는 기법
    - 클럭 속도 상승 시 CPU 성능 증가
    - 클럭 속도 필요 이상 상승 시 발열이 심각

### 클럭 속도의 한계

- 속도만 높인다고 무조건 CPU가 빨라지는 것이 아니다.
- 고성능을 요구하는 작업을 장시간 처리 시 발열 문제가 심각해질 수 있다.

### 클럭 속도를 늘리는 방법 이외의 방법

- 코어 수 증가, 스레드 수 늘리기.

## 코어와 멀티코어

### **CPU 성능을 높이는 방법**

- CPU의 코어 수와 스레드 수를 늘려서 성능을 향상시킴
- 기술의 발전에 따라 CPU 내부에 명령어를 처리하는 부품인 코어를 여러 개 설계할 수 있음

### **코어(core)**

- 명령어를 실행하는 부품
- CPU 내에서 명령어를 실행하는 부품으로 프로세스 안에 여러개가 있게 되었다

### **멀티코어(multi-core)**

- 멀티코어(multi-core) CPU: 코어를 여러 개 포함하고 있는 CPU로 멀티코어 프로세서라고도 불림
- 멀티코어 처리 속도는 단일 코어보다 일반적으로 빠름
    - ex> 2.3GHz 단일 코어 CPU보다 2.0GHz의 멀티코어 CPU가 일반적으로 성능이 뛰어남

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/02b3a4f2-2b22-4e4f-a9fe-0014c48f0d5b/7128ab99-0325-4b19-bdab-ec7a52d58f04/Untitled.png)

### 멀티 코어의 한계

- CPU 연산 속도가 코어 수에 비례해 증가하는 것은 아니다.
- 코어에 처리할 연산이 적절히 분배되지 않으면 코어 수에 비해서 성능 향상이 크지 않다.
- 처리할 작업량보다 코어 수가 지나치게 많을 때도 성능 향상 폭이 크지 않다.
- **따라서 코어마다 처리할 명령어들을 얼마나 적절히 분배하는지에 따라 연산 속도가 크게 달라진다.**

## 스레드와 멀티스레드

### 스레드(thread)

- 실행 흐름의 단위로 하드웨어적 스레드와 소프트웨어적 스레드로 나뉜다.
- 하드웨어적 스레드
    - CPU에서 사용되는 스레드
- 소프트웨어적 스레드
    - 프로그램에서 사용되는 스레드

### **하드웨어적 스레드**

- **하나의 코어가 동시에 처리하는 명령어 단위**
- **논리 프로세서(logical process)라고도 부른다**.

- 여러 스레드를 지원하는 CPU는 하나의 코어로 여러 개 명령어를 동시에 실행할 수 있다.
    - ex> 2코어 4스레드 CPU는 명령어를 실행하는 코어 2개를 포함하고, 각 코어는 2개의 명령어( 2 x 2 = 4) 를 실행할 수 있다.
    

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/02b3a4f2-2b22-4e4f-a9fe-0014c48f0d5b/1cb7f01a-bf24-4103-a3c5-73d416a2e8ee/Untitled.png)

- 멀티스레드(multithread) 프로세서: 하나의 코어로 여러 명령어를 동시에 처리하는 CPU로 멀티스레드 CPU로도 불림. ( **하드웨어 스레드를 여러개 가진다**)
    - 하이퍼스레딩(hyper-threading): 인텔의 멀티스레드 기술

### **소프트웨어적 스레드**

- **하나의 프로그램에서 독립적으로 실행되는 단위**
- 일반적으로 스레드 라고 칭한다.
- 하나의 프로그램에서 서로 독립된 작업들은 동시에 실행될 수 있다.
    - ex> 입력받은 내용들을 화면에 출력하면서 동시에 입력된 내용들을 저장하는 프로그램
- 1코어 1스레드 CPU도 소프트웨어적 스레드를 여러 개 실행할 수 있다. 즉, 소프트웨어적 스레드는 프로그램의 여러 부분을 동시에 실행하는 것

### **멀티스레드 프로세서**

- 멀티스레드 프로세서를 구성하는데 레지스터가 중요한 역할을 한다.
- 하나의 명령어를 처리하려면 하나의 레지스터 세트가 필요하다.
- 따라서 멀티스레드 프로세스는 여러 명령어를 동시에 처리하기 위해 레지스터 세트를 여러 개 들고 있다.

### 참고

> cf. Intel 12세대 이후
> 
> 
> 책의 예시에서는 4코어 CPU가 8개의 논리 프로세서를 가지는 것을 볼 수 있었습니다. 이는 각각이 하이퍼스레딩이 가능한 코어이기 때문에 코어 하나에서 2개의 명령어를 처리하면서 나타난 결과입니다.
> 
> 그러나 제 컴퓨터를 확인해 보니 코어는 14개인데 논리 프로세서가 20개임을 확인할 수 있었습니다.
> 
> !https://velog.velcdn.com/images/cheeeedy/post/5f8d7bb3-c0ef-4dff-96bb-8cae573e639f/image.png
> 
> 왜 이런 결과가 나타났는 지 확인하기 위해 찾아보니 인텔 12세대부터는 새로운 아키텍쳐가 적용되면서 Performance Core(P-core)와 Efficient Core(E-core)의 두 가지 형태의 코어가 적용되었다고 합니다. 이러한 구조는 이미 모바일 프로세서에서는 적용된 설계 형태였지만 PC에 사용하는 인텔 CPU에서는 12세대부터 적용되었다고 합니다.
> 
> !https://velog.velcdn.com/images/cheeeedy/post/743cda54-6191-44b3-b51f-05aa7b55a98a/image.png
> 
> P-core의 경우 기존의 코어와 동일하게 하이퍼스레딩이 가능하고, E-core의 경우 하이퍼스레딩이 적용되지 않는 대신 전력 효율이 좋다고 합니다. 이 때문에 제 PC의 경우 논리 프로세서가 P-core에서 6*2 = 12개 + E-core에서 8개 총 20개였습니다.
> 
> 위와 같은 특징 때문에 게임 엔진 개발 시 [GPU에게 빠르게 연산 결과를 주고 받아야하는 렌더링 작업은 P-core에, 비동기적으로 실행되는 작업을 E-core에서 처리하도록 설계한다면 CPU 부하를 줄일 수 있다](https://www.intel.com/content/www/us/en/developer/articles/guide/12th-gen-intel-core-processor-gamedev-guide.html?wapkw=e-core%20p%3Dcore#inpage-nav-5-4)고 합니다.
> 

# 2. 명령어 병렬 처리 기법

### 명령어 병렬 처리 기법 (Instruction-Level Parallelism, ILP)

- 명령어를 동시에 처리해 CPU를 쉬지 않고 작동시키는 방법
- 명령어 파이프라이닝, 슈퍼스칼라, 비순차적 명령어 처리 등이 있다.

### 명령어 파이프라인

- 명령어는 같은 처리 단계는 동시에 실행할 수 없다.
- 달리 말하면 CPU는 "다른 단계에 있는 여러 명령어는 동시에 실행할 수 있다"

### 명령어 처리 단계 ( 명령어 처리 과정을 클럭 단위로 나누었을 때 )

1. 명령어 인출(Instruction Fetch)
2. 명령어 해석(Instruction Decode)
3. 명령어 실행(Execute Instruction)
4. 결과 저장 (Write Back)

### 명령어 파이프라인(Instruction Pipeline)

- 명령어 파이프라이닝(Instruction pipelining): 동시에 여러 개 명령어를 겹쳐서 실행하는 기법
- 명령어를 겹처서 실행하면 하나씩 실행하는 것보다 훨씬 효율적으로 처리할 수 있다.
- 아래와 같이 동시간에 여러 명령어의 다른 단계들을 동시에 처리할 수 있다.

!https://blog.kakaocdn.net/dn/lvCyL/btrP7UcmtXN/rawQ4NfnmFjwkBIkE9mdJK/img.png

### 파이프라인 위험(pipeline hazard)

- 특정 상황에서는 파이프라이닝이 성능 향상에 도움을 주지 못하는 경우를 의미함

### 종류

- 데이터 위험, 제어 위험, 구조적 위험이 존재

### 데이터 위험(data hazard)

- 데이터 의존적인 두 명령어를 실행하려고 할 때 파이프라인이 제대로 동작하지 않는 경우
- 즉, 명령어 간 **"데이터 의존성"**에 의해 발생함
- 어떤 명령어가 이전 명령어가 끝까지 실행되기 전까지는 실행하기 어려운 경우

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/02b3a4f2-2b22-4e4f-a9fe-0014c48f0d5b/b6110758-26b9-451a-94d7-7cee7d045bd0/Untitled.png)

### 제어 위험(control hazard)

- 분기 등으로 인한 "프로그램 카운터의 갑작스러운 변화"로 발생
- **분기로 인해서 명령어 파이프라인이 미리 처리 중이던 명령어들은 쓸모 없게 돼버리는 현상**
- 분기 예측(branch prediction): 제어 위험을 방지하기 위해 사용하며, 프로그램이 어디로 분기할지 예측하고 그 주소를 인출하는 기술

### 구조적 위험(structural hazard)

- 명령어 파이프라인에서 서로 다른 명령어가 동시에 ALU, 레지스터 등의 CPU 부품에 접근할 때 발생함
- 자원 위험(resource hazard)라고도 불림

### 요약

- 명령어 파이프라인(Instruction Pipeline)을 사용하면 더 빠르게 실행이 가능하다
- 명령어 파이프라인이 작동을 안하는 경우가 있는데 그것이 파이프라인 위험이다.
- 파이프라인 위험에는 데이터 위험, 제어 위험, 구조적 위험 3가지가 있다.

---

### 슈퍼스칼라

슈퍼 스칼라(superscalar)

- CPU 내부에 여러 개의 명령어 파이프라인을 포함한 구조
- 요즘 대부분 CPU는 여러 개 파이프 라인을 사용하고 있음
- 슈퍼스칼라 프로세서: 슈퍼스칼라 구조의 명령어 처리가 가능한 CPU. 슈퍼스칼라 CPU라고도 부름
    - 장점: 이론적으로 파이프라인 개수에 비례해 프로그램 처리 속도가 빨라짐
    - 단점: 실제로 파이프라인 위험 등 예상치 못한 상황에서는 파이프라인 개수에 비례해 빨라지진 않음
    - 따라서 **파이프라인 위험을 방지하는 방향으로 고도화한 설계가 필요**하다.

!https://blog.kakaocdn.net/dn/dzMdHF/btrP7TEwN25/2uUV1k0coG4L5quBk3pRS1/img.png

### 비순차적 명령어 처리

비순차적 명령어 처리(Out-of-order execution, OoOE)

- 명령어를 순차적으로 실행하지 않는 기법
- 선순위 명령어가 실행되는 명령어들과 데이터 의존성이 있을 때 순서를 바꿔 처리해도 되는 후순위 명령어들을 먼저 처리하는 방법
- CPU 성능 향상에 크게 기여한 기법으로 오늘날 대부분의 CPU가 차용한 기법
- 비순차적 명령어 처리가 가능한 CPU는 명령어가 어떤 명령어들과 데이터 의존성이 있는지, 순서를 바꿔서 실행할 수 있는지를 판단할 수 있어야 한다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/02b3a4f2-2b22-4e4f-a9fe-0014c48f0d5b/4a67cf84-5e63-46a4-8e87-54d01b0601e0/Untitled.png)

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/02b3a4f2-2b22-4e4f-a9fe-0014c48f0d5b/fd43ae7a-c29a-436e-9846-c3774211414c/Untitled.png)

### 요약

- 슈퍼스칼라는 여러 개의 명령어 파이프라인을 두는 기법
- 비순차적 명령어 처리 기법은 파이프라인 중단을 방지하기 위해 명령어를 순차적으로 처리하지 않는 기법

# 3. CISC와 RISC

### 명령어의 형태

- 효율적인 파이프라이닝을 위해 명령어가 최적화 되어야 함
- 최적화된 명령어란 파이프라이닝을 하기 쉬운 형태로 된 명령어를 의미함

### 1) 명령어 집합

- CPU가 이해할 수 있는 명령어들의 모음
- 명령어 집합 구조(Instruction Set Architecture, ISA)라고도 부름
    - CPU의 명령어 이해 방식에 따라 컴퓨터 구조 및 설계 방식이 달라질 수 있기 때문에 "구조"라는 단어를 사용
- 일종의 CPU 언어로 이해할 수 있다.
- CPU마다 ISA가 다를 수 있다.
    - **ex)** 인텔 CPU 컴퓨터와 맥은 서로의 명령어를 이해할 수 없다.
- 명령어의 차이에 따른 어셈블리어에도 차이 발생
    - 같은 소스 코드로 이루어진 프로그램이라도 ISA에 따라 서로 다른 어셈블리어 형태를 갖게 됨
    - 제어장치가 명령어를 해석하는 방식, 사용되는 레지스터의 종류와 개수, 메모리 관리 방법에도 차이 발생

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/02b3a4f2-2b22-4e4f-a9fe-0014c48f0d5b/d310114c-2efb-4086-94c4-2b2b5ba94a21/Untitled.png)

같은 코드도 컴퓨터마다 다른 명령어(어셈블리어)로 컴파일된다. (좌: x86-64 ISA, 우: ARM ISA)

ISA의 특징

- CPU가 어떤 ISA를 쓰느냐에 따라 많은 것이 달라질 수 있다.
    - 제어장치가 명령어를 해석하는 방식
    - 사용하는 레지스터 종류와 수
    - 메모리 관리 방법
- 따라서 **ISA는 CPU 하드웨어 설계 방식에 큰 영향**을 미친다.
- **명령어 병렬 처리에 적절한 ISA와 적절하지 못한 ISA가 존재**한다.

## 명령어 집합의 종류

## 1. CISC (Complex Instruction Set Computer)

- 복잡한 과정 처리가 가능한 다양한 명령어를 활용하는 CPU 설계 방식
- 명령어 형태와 크기가 다양한 **가변 길이 명령어**를 활용함

### 장점

- 상대적으로 적은 수의 명령어로도 프로그램을 실행할 수 있음
- 메모리를 최대한 절약하며 쓸 수 있어 과거에 인기가 높았다.

### 단점

- 명령어의 크기가 다르고, 명령어 실행 시간이 일정하지 않음.
- 복잡한 명령어로 명령어 하나를 실행하는데 여러 클럭 주기를 요구함
- 즉, 명령어 파이프라이닝이 불리하다

### CISC의 한계

- CISC는 명령어마다 처리 시간이 달라지기 때문에 **명령어 파이프라인을 구현하기 어렵다.**
    - 즉, 명령어가 규격화돼 있지 않아서 파이프라인을 어렵게 만든다.
- CISC는 복잡한 연산을 가능케하는 다양한 명령어들이 존재하지만 대부분 사용빈도는 낮다.
    - 즉, 자주 사용되는 명령어들만 쓰이는 것이다.

## 2. RISC (Reduced Instruction Set Computer)

- CISC의 한계를 극복하기 위해 등장한 명령어

### 특징

- CISC에 비해 명령어 종류가 적다
- 명령어를 규격화해 되도록 1클럭 내외로 실행되는 명령어를 지향함
- 고정 길이 명령어를 활용함

### 장점

- 명령어 파이프라이닝에 최적화 됨

### 단점

- 프로그램을 실행하는데 CISC보다 많은 명령어가 필요함

### RISC의 메모리 접근

- RISC는 메모리에 직접 접근하는 명령어를 load, store 두개로만 표현 ( 최소화 )
- 즉, 단순화된 명령어만을 최소로 남겨서 파이프라이닝을 효율적으로 가능하게 함
- 메모리 접근은 단순화한 대신 레지스터를 적극적으로 활용함
- 따라서 레지스터를 이용하는 연산이 많고, 일반적으로 범용 레지스터의 수도 많다.

### CISC와 RISC 비교

| CISC | RISC |
| --- | --- |
| 복잡하고 다양한 명령어 | 단순하고 적은 명령어 |
| 가변 길이 명령어 | 고정 길이 명령어 |
| 다양한 주소 지정 방식 | 적은 주소 지정 방식 |
| 프로그램을 표현하는 명령어 수가 적음 (메모리 효율적) | 프로그램을 표현하는 명령어 수가 많음 (메모리 비효율적) |
| 여러 클럭에 걸쳐서 명령어가 수행됨 | 1클럭 내외로 명령어를 실행함 |
| 파이프라이닝이 어려움 | 파이프라이닝에 효율적임 |

### 요약

- CISC는 복잡하고 다양한 종류의 가변 길이 명령어 집합을 활용
- RISC는 단순하고 적은 종류의 고정 길이 명령어 집합을 활용
    - 파이프라이닝을 효율적으로 가능
