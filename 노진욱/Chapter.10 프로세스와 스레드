노션 링크: https://luxuriant-tibia-a88.notion.site/Chapter10-463d4b1632814205969d5a099819a5d4?pvs=4

# Chapter10. 프로세스와 스레드

### 10-1. 프로세스 개요

프로세스(process)

- 보조기억장치에 저장된 프로그램을 메모리에 적재하고 실행할 때의 프로그램
- **프로세스를 생성한다** 고 표현함

프로세스 확인하기

- 윈도우: **작업 관리자** -> **프로세스 탭**

!https://blog.kakaocdn.net/dn/cCvEK8/btrR6d60diq/FeIKW23mCiKYMANzAWzu0K/img.png

- 유닉스 체계: **ps 명령어**

!https://blog.kakaocdn.net/dn/bwhPgX/btrR308oxKj/RD8a1kuHY3yqkRYBWl8J91/img.png

프로세스 유형

- 포그라운드 프로세스(foreground process): 사용자가 보는 앞에서 실행되는 프로세스
- 백그라운드 프로세스(background process): 사용자가 보지 못하는 뒤편에서 실행되는 프로세스
    - 사용자와 상호작용하는 백그라운드 프로세스와 그렇지 않은 프로세스가 있다.
    - 데몬(demon): 유닉스 체계 운영체제에서 사용자와 상호작용하지 않는 프로세스를 부르는 명칭
    - 서비스(service): 윈도우 체계 운영체제에서 사용자와 상호작용하지 않는 프로세스를 부르는 명칭

!https://blog.kakaocdn.net/dn/KDj5R/btrR2S4lvk4/vMOdic5vA5NcszkbSZZFNk/img.png

---

### 프로세스의 CPU 할당

1. 프로세스는 차례대로 돌아가며 한정된 시간동안 CPU를 사용한다.
2. 본인의 차례가 되면 정해진 시간만큼 CPU를 이용한다.
3. 시간이 끝났음을 알리는 하면 자신의 차례를 양보하고 다음 차례를 기다린다.
    
    타이머 인터럽트가 발생
    
- 타이머 인터럽트: 클럭 신호를 발생시키는 장치에 의해 주기적으로 발생하는 하드웨어 인터럽트
    - 타임아웃 인터럽트라고도 불린다.

### 프로세스 제어 블록(PCB; Process Control Block)

- 프로세스와 관련된 정보를 저장하는 자료구조
- 운영체제는 PCB를 이용해 프로세스 실행 순서를 관리하고, 프로세스에 CPU 등 자원을 배분한다.
- 프로세스 제어 블록에는 해당 프로세스 식별을 위해 꼭 필요한 정보들이 저장된다.

PCB 특징

- 커널 영역에서 생성된다.
- 프로세스 실행 시에 PCB가 생성되고, 종료 시에 PCB는 삭제된다.

PCB에 저장되는 정보

- **프로세스 ID (PID; Process ID)**
    - 특정 프로세스를 식별하기 위해 부여하는 고유 번호

!https://blog.kakaocdn.net/dn/lJKR1/btrR2GXiAix/kuVmOrlSiR04vVq4k5S2cK/img.png

- **레지스터 값**
    - 프로세스가 이전에 사용했던 레지스터 값들을 저장
    - 프로세스가 실행차례가 되었을 때 저장된 레지스터 중간 값들을 모두 복원 후 재실행
- **프로세스 상태**
    - 프로세스의 상태를 저장
    - 프로세스가 CPU 사용을 기다리는지, 입출력장치 사용을 기다리는지, CPU를 이용하는지 등이 기록
- **CPU 스케줄링 정보**
    - 프로세스가 언제, 어떤 순서로 CPU를 할당 받을지에 대한 정보
- **메모리 관리 정보**
    - 프로세스가 메모리 어디에 저장돼 있는지에 대한 정보
    - 프로세스의 메모리 정보를 알 수 있는 페이지 테이블 정보가 담김
- **사용자 파일과 입출력 장치 목록**
    - 특정 입출력장치나 파일을 사용했던 기록

---

### 프로세스 교환

- A 프로세스에 주어진 실행 시간이 종료 시 다른 B 프로세스에 CPU 사용을 양보해야 한다.
- 양보 전에 프로세스 A는 프로그램 카운터 등 레지스터 값, 메모리 정보, 이전에 사용한 파일과 입출력장치 정보 등 중간 정보들을 백업해야 한다.
- 백업 후 다음 차례가 왔을 때 다시 복원해 실행을 재개하게 된다.

문맥 교환

- 문맥(context): 하나의 프로세스 실행을 재개하기 위해 필요한 중간 정보들
- 프로세스 문맥은 PCB에 기록돼 있으며, CPU 사용 시간이 종료되거나 인터럽트가 발생할 때 운영체제는 해당 프로세스의 PCB에 문맥을 백업한다.
- 뒤에 실행을 재개하는 프로세스는 PCB에서 문맥을 복원해서 실행을 재개한다.
- 문맥 교환(context switching): 기존 프로세스의 문맥을 PCB에 백업하고, 새로운 프로세스의 문맥을 PCB로 부터 복구해 실행을 재개하는 과정
- 문맥 교환을 통해 여러 프로세스는 빠르게 번갈아 가며 실행되며, 빠르게 진행될수록 프로그램은 동시에 실행되는 것처럼 보인다.
    - 단, 문맥교환이 너무 자주 발생하면 오버헤드가 발생할 수 있기 때문에 문맥교환이 자주 발생하는게 꼭 좋은 것은 아니다.

---

### 프로세스의 메모리 영역

### 사용자 영역의 코드 배치

사용자 영역은 4가지 영역으로 세분화된다.

1. **코드 영역**
2. **데이터 영역**
3. **힙 영역**
4. **스택 영역**

1. 코드 영역(code segment)

- 실행할 수 있는 코드(기계어 명령어)가 저장된다.
- 데이터가 아닌 CPU가 실행할 명령어들만 담겨있기 때문에 이다.
    
    읽기 전용(read-only) 공간
    
    - 즉, 쓰기 행위가 금지된다.
- 텍스트 영역(text segment)라고도 불린다.

2. 데이터 영역(data segment)

- 프로그램이 실행되는 동안 유지해야 할 데이터가 저장되는 공간
    - 변경되는 데이터들은 힙이나 스택 영역에 저장된다.
- 전역변수(global variable)와 같이 프로그램 실행동안 데이터가 유지되며, 프로그램 전체에서 접근할 수 있는 데이터들이 저장된다.

3. 힙 영역(heap segment)

- 프로그래머가 직접 할당할 수 있는 영역
- 프로그래밍 과정에서 힙 영역에 메모리 할당이 발생했으면, 언젠가 다시 반환해야 한다.
- 메모리 공간을 반환하지 않으면 할 수 있다.
    
    메모리 누수(memory leak)가 발생
    
    - 메모리 내에 할당한 공간이 계속 사용되고 있어서 메모리 낭비가 발생

4. 스택 영역(stack segment)

- 일시적으로 데이터를 저장하는 공간
- 데이터 영역과 달리 데이터는 일시적으로만 저장된다.
    - 지역 변수, 함수 실행이 끝나면 사라지는 매개 변수 등이 있다.
    - 일시적으로 저장할 데이터는 스택 영역에 **PUSH** 하고, 필요하지 않은 데이터는 **POP** 하여 스택 영역에서 제거

영역별 특징

- 정적 할당 영역: 크기가 고정된 영역으로 영역의 크기가 변하지 않는다.
    - 코드 영역과 데이터 영역이 이에 해당됨
- 동적 할당 영역: 프로그램 실행 과정에서 크기가 변할 수 있는 영역이다.
    - 힙 영역과 스택 영역이 이에 해당됨

힙 영역과 스택 영역

- 힙 영역은 낮은 주소에서 높은 주소로 메모리가 할당됨
- 스택 영역은 높은 주소에서 낮은 주소로 메모리가 할당됨
- 이를 통해 함
    
    새롭게 할당하는 주소가 겹치지 않게 처리
    

---

### 10-2. 프로세스 상태와 계층 구조

### 프로세스 상태

- 운영체제는 프로세스의 상태를 PCB에 기록하고 관리한다.
- 하나의 프로세스는 여러 상태를 거치며 실행된다.

프로세스 상태 종류

1. 생성 상태(new)

- 프로세스가 생성 중인 상태
- 메모리에 적재돼 PCB 할당을 받은 상태
- 생성 후 준비가 된 프로세스들은 준비 상태가 되어 CPU 할당을 대기함

2. 준비 상태(ready)

- 본인이 실행되기를 기다리고 있는 상태
- 차례가 돼 CPU 할당을 받으면 실행 상태가 됨
- 디스패치(dispatch): 준비 상태인 프로세스가 실행 상태로 전환되는 것을 지칭

3. 실행 상태(running)

- CPU를 할당받아 실행 중인 상태
- CPU가 할당된 시간동안 프로세스는 실행될 수 있다.
- 프로세스가 할당된 시간을 모두 사용하면(타이머 인터럽트가 발생하면) 다시 준비 상태가 된다.
- 실행 도중 입출력장치 작업을 대기하게 된다면 대기 상태가 된다.

4. 대기 상태(blocked)

- 입출력장치의 작업을 기다리는 상태로 입출력이 끝날 때까지 (입출력 인터럽트를 받을 때까지) 대기한다.
- 특정 이벤트가 일어나길 기다리는 경우에도 대기상태가 된다.
- 대기 상태가 끝나면 프로세스는 다시 준비 상태로 돌아가 CPU 할당을 준비한다.

5. 종료 상태(terminated)

- 프로세스가 종료된 상태
- 프로세스가 종료되면 운영체제는 PCB와 프로세스가 사용한 메모리를 정리한다.

프로세스 상태 다이어그램(process state diagram)

- 프로세스의 여러 상태들을 나타낸 도표
- 도표처럼 컴퓨터 내의 프로세스는 생성, 준비, 실행, 대기, 종료 상태를 반복하며 실행된다.
- 운영체제는 PCB에 각 프로세스의 상태들을 기록하고 관리한다.

!https://blog.kakaocdn.net/dn/dg0xOJ/btrR35aJN4t/k8kS5pMVpKKHSEt1QxXkZ1/img.png

---

### 프로세스의 계층 구조

부모 프로세스와 자식 프로세스

- 프로세스는 실행 중 시스템 호출을 통해 다른 프로세스를 생성할 수 있다.
    - 부모 프로세스(parent process): 새 프로세스를 생성한 프로세스
    - 자식 프로세스(child process): 부모 프로세스에 의해 생성된 프로세스
- 부모 프로세스와 자식 프로세스는 서로 다른 프로세스이기 때문에 다른 PID를 가진다.
- 자식 프로세스의 부모 프로세스 PID가 기록되기도 한다.
    - PPID(Parent PID): 부모 프로세스의 PID

프로세스 계층 구조

!https://blog.kakaocdn.net/dn/Ukc2x/btrR2Gwlfk9/CRUIxdqDBReFORuqkEdbH1/img.png

- 트리 구조를 띄는 프로세스들의 계층적인 구조를 의미함
- 프로세스들은 부모와 자식 관계의 계층적 구조를 가진다.
- 운영체제들은 프로세스의 계층 구조를 통해 프로세스를 관리한다.
- 컴퓨터 실행 시 하고, 다시 자식 프로세스들이 프로세스들을 생성하는 구조로 여러 프로세스들이 실행된다.
    
    최초의 프로세스(PID: 1)가 자식 프로세스들을 생성
    

최초의 프로세스

- 컴퓨터가 부팅될 때 생기는 프로세스로 이다.
    
    PID는 1
    
    - 유닉스 운영체제: init
    - 리눅스 운영체제: systemd
    - macOS: launchd
- 모든 프로세스의 다.
    
    최상단에 위치한 부모 프로세스
    
- pstree를 통해 프로세스의 계층 구조를 확인할 수 있다 (root가 아니면 실행안되는듯...?).

---

### 프로세스 생성 기법

- 프로세스 생성은 **fork**와 **exec**을 통해 이루어진다.
    - fork: 자신의 복사본을 자식 프로세스로 생성해내는 방법
    - exec: 자신의 메모리 공간을 다른 프로그램으로 교체하는 방법
- fork와 exec은 이다.
    
    시스템 호출
    
- 즉, 프로세스를 실행하는 과정은으로 여러 프로세스는 계층적으로 fork와 exec을 실행함
    
    fork와 exec이 반복되는 과정
    

fork

- fork된 자식 프로세스는 부모 프로세스의 복사본이다.
- 부모 프로세스의 자원(메모리 내용, 열린 파일 목록 등) 등 정보가 복사된다.

exec

- 자식 프로세스는 exec을 통해 새로운 프로그램으로 전환할 수 있다.
- exec은 메모리 공간을 새로운 프로그램으로 덮어쓰는 시스템 호출이다.

---

### 10-3. 스레드

### 프로세스와 스레드

스레드(thread)

- 실행의 단위로 프로세스를 구성하는 실행의 흐름 단위다.
- 하나의 프로세스는 여러 스레드를 가질 수 있다.
- 스레드를 이용해서 하나의 프로세스에서 여러 부분을 동시에 실행할 수 있다.
- 단일 스레드 프로세스: 하나의 실행 흐름(스레드)을 가져, 한번에 한 부분만 실행되는 프로세스

스레드의 특징

- 스레드는 각기 다른 스레드 ID, 프로그램 카운터 값을 포함한 레지스터 값, 스택으로 구성됨
- 따라서 각 스레드는 서로 다른 코드를 동시에 실행할 수 있음
- 스레드는 프로세스의 자원은 공유함
- 즉, 실행에 필요한 최소한의 정보(레지스터, 스택)만 분리한 채 프로세스 자원을 공유하며 실행됨
- 최근에 많은 운영체제는 CPU에 처리할 작업단위를 스레드 단위로 전달함

리눅스에서의 프로세스와 스레드

- 리눅스에서는 프로세스와 스레드를 구분짓지 않음
- 둘 모두 에서 동등하다고 간주함
    
    실행의 문맥(context of execution) 관점
    
- 프로세스와 스레드보다는 태스크(task)라는 이름으로 통일해 명명함

---

### 멀티프로세스와 멀티스레드

멀티프로세스와 멀티스레드의 개념

- 멀티프로세스(multiprocess): 여러 프로세스를 동시에 실행하는 것
- 멀티스레드(multithread): 여러 스레드로 프로세스를 동시에 실행하는 것

멀티프로세스와 멀티스레드의 차이

- 프로세스는 프로세스간 자원을 공유하지 않지만, 스레드는 같은 프로세스 내의 자원을 공유한다.
- 멀티프로세스
    - 동일 작업을 하는 프로세스의 경우, fork를 통해 모든 자원을 복제해 메모리에 적재한다. 즉, 동일한 프로세스 두 개가 각각 메모리에 적재된다.
- 멀티스레드
    - 프로세스가 가진 자원을 공유한다.
    - 스레드간 차이는 스레드 ID, 프로그램 카운터를 포함한 레지스터 값, 스택만 차이를 가진다.

멀티프로세스와 멀티스레드의 장단점

멀티프로세스 장점

- 각 프로세스간 독립적이기 때문에 하나의 프로세스에 문제가 생겨도 영향이 적다.

멀티프로세스 단점

- 동일한 프로그램 실행을 위해 메모리에 같은 내용이 중복돼 적재되기 때문에 메모리 낭비로 볼 수 있다.
- 자원을 공유하지 않기 때문에 서로 독립적으로 실행된다.

멀티스레드 장점

- 여러 프로세스를 병행실행하는 것보다 메모리를 효율적으로 사용한다.
- 스레드간 협력과 통신에 유리하다.

멀티스레드 단점

- 스레드간 같은 자원을 공유하기 때문에 하나의 프로세스에서 발생한 문제가 전체 스레드에 영향을 줄 수 있다.

---

프로세스 간 통신(IPC; Inter-Process Communication)

- 프로세스 간 자원을 공유하고 데이터를 주고 받는 방법
- 파일을 통한 프로세스 간 통신: 여러 프로세스가 동일 파일에 접근할 시, 해당 파일의 데이터를 통해 프로세스 간 통신이 이루어진다는 의미
- 공유 메모리(shared memory): 프로세스간 서로 공유하는 메모리 영역으로 공유 메모리를 통해 프로세스간 데이터를 주고 받는다.
- 이외에도 프로세스들은 할 수 있다.
    
    소켓, 파이프 등을 통해 통신
    
- 단, 스레드에 비해 자원 공유는 까다로울 수 있다.
