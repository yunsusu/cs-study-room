# 노션 링크
- https://luxuriant-tibia-a88.notion.site/Chapter3-0ebab7c6b6804d8eabc47d00544bb822?pvs=4
# Chapter3. 명령어

# **요약**

고급언어와 저급언어의 차이를 정리하고, 저급언어인 명령어가 어떻게 구성되는지 알 수 있었다.

# **내용 정리**

### 03-1. 소스코드와 명령어

(1) 고급언어와 저급언어

프로그래밍 언어로 만든 소스 코드들이 실행되려면 컴퓨터 내부에서 이해할 수 있는 명령어로 변환이 되야 한다.

- 고급 언어(high-level programming language): 프로그래밍 언어와 같이 사람이 이해하기 쉽게 만들어진 언어
    - ex> C, C++, Java, Python 등

고급언어의 필요성

- 사람이 읽고 쓰기 편하다.
- 가독성이 좋다.
- 변수나 함수 등 문법을 이용해 복잡한 프로그램을 구현할 수 있다.
- 저급 언어(low-level programming language): 컴퓨터가 이해할 수 있는 언어로 명령어가 이에 속한다.

저급언어의 종류

!https://blog.kakaocdn.net/dn/qzgBn/btrPynrlo0r/TartNukW3p7uq5ZuW3rrk1/img.png

기계어와 어셈블리어

- 기계어(machine code): 0과 1의 명령어 비트로 이루어진 언어
    - 이진수로 나열 시 너무 길어지기 때문에 가독성을 위해 십육진수로 나타내기도 한다.
    - 사람이 읽고 이해하기 어렵다.
- 어셈블리어(assembly language): 기계어를 사람이 어느정도 이해할 수 있는 형태로 번역한 언어
    - 어셈블리어 역시 저급언어라 이를 이용해서 복잡한 프로그램을 만들기 쉽지 않다.
- 

**저급언어의 필요성**

- 하드웨어와 밀접한 임베디드 개발자, 게임 개발자, 정보 보안 분야 등은 저급언어 (어셈블리어)를 이용할 일이 많다.
- 언어의 "작성" 뿐만 아니라 "관찰"의 시점에서 중요하다.
- 어셈블리어를 읽으면서 컴퓨터 프로그램 실행 과정을 파악하고, 각 절차를 추적하고 관찰할 수 있다.

(2) 컴파일 언어와 인터프리터 언어

- 컴파일 언어: 컴파일러에 의해 소스 코드 전체가 저급 언어로 변환 후 프로그램이 실행되는 고급 언어
    - ex> C
- 컴파일(compile): 컴파일 언어로 작성된 소스 코드 전체가 저급 언어로 변환되는 과정
- 컴파일러(compiler): 컴파일을 수행해주는 도구로 전체 소스 코드를 저급 언어로 컴파일하며, 크게 아래 과정을 수행함
    - 개발자가 작성한 소스코드 전체에서 문법적인 오류는 없는지
    - 실행 가능한 코드인지
    - 실행하는데 불필요한 코드는 없는지
    - 컴파일러가 소스 코드 내 오류를 발견하면 컴파일을 실패하게 됨
- 목적 코드(object code): 컴파일러를 통해 저급 언어로 변환된 코드
- 인터프리터 언어: 인터프리터에 의해 소스 코드가 한 줄씩 실행되는 고급 언어
    - ex> Python
    - 코드를 한줄씩 차례대로 실행
    - 소스코드를 저급언어로 변환하는 시간을 기다리지 않고 바로 실행 가능함
    - 소스 코드 내 N번째 줄에 오류가 있더라도 N-1번째 줄까지는 정상적으로 실행이 가능함
- 인터프리터(interpreter): 소스코드를 한줄씩 저급 언어로 변환해 실행해주는 도구

컴파일 언어와 인터프리터 언어

- 인터프리터 언어는 일반적으로 컴파일 언어보다 느리다.
    - 컴파일 언어는 소스코드 전체를 저급언어로 변환한 후 실행하는 반면,
    - 인터프리터 언어는 소스 코드 줄마다 저급언어로 변환하여 실행하여야 하기 때문
- 컴파일 언어와 인터프리터 언어를 명확히 구분하는 것이 어렵다.
    - 여러 프로그래밍 언어들이 두가지 방식을 혼용해 사용하기 때문

목적 파일 vs 실행 파일

- 목적 파일: 목적 코드로 이루어진 파일
    - C에서는 *.o 형태의 확장자를 가진다.
    - .o는 소스 파일(*.c) 내용을 저급 언어로 변환한 파일일 뿐 실행할 수는 없다.
    - 실행을 위해서는 링킹 작업이 필요하다.
- 링킹: 목적 코드가 실행 파일이 되기 위해 거치는 작업
    - 목적 파일에는 없는 외부 기능들을 연결하는 작업
    - 링킹 작업이 완료되면 하나의 실행 파일이 생성된다.
- 실행 파일: 코드를 실행하는 파일
    - 실행 파일 생성 과정: 소스 파일(*.c) -> 컴파일 -> 목적 파일(*.o) -> 링킹 -> 실행 파일

### 03-2. 명령어의 구조

- 명령어: 연산 코드 + 오퍼랜드
    - 어떤 '작업'을 '무엇'이 수행해라는 구조로 되어 있음
- 연산 코드(operation code): 명령어가 수행할 연산으로 연산자라고 불림
- 오퍼랜드(operand): 연산에 사용할 데이터 또는 연산에 사용할 데이터가 저장된 위치로 피연산자로 불림
    - 주소 필드라고도 불린다.
    - 숫자와 문자 등 데이터를 직접 명시하거나 메모리나 레지스터 주소 등 간접 명시한다.
    - 대부분은 연산에 사용할 데이터의 위치(메모리 주소 또는 레지스터 이름)가 입력된다.
    - 명령어 내에 오퍼랜드는 존재하지 않거나, 여러 개 있을 수 있다.
    - 오퍼랜드 개수에 따라 0-주소 명령어, 1-주소 명령어, 2-주소 명령어, 3-주소 명령어 등으로 나뉘게 된다.

!https://blog.kakaocdn.net/dn/cATC7u/btrPDr9pGk6/Fq1RqzJOA1HdaI9YTl8N30/img.png

연산 코드 필드와 오퍼 랜드 필드

명령어는 그림처럼 연산 코드가 담기는 연산 코드 필드와 오퍼랜드가 담기는 오퍼랜드 필드로 표현된다.

- 명령어인 기계어와 어셈블리어도 연산 코드와 오퍼 랜드로 구성된다.

연산 코드 유형

- 데이터 전송
- 산술/논리 연산
- 제어 흐름 변경
- 입출력 제어

오퍼랜드에 데이터를 간접 명시(주소) 하는 이유

- 명령어의 길이 때문에 간접 명시하는 경우가 많음
- ex> 명령어 크기가 16비트이고 연산 코드 필드가 4비트인 경우는 오퍼랜드에 사용할 수 있는 크기가 12비트이다. 이 때 3-주소 명령어인 경우, 각 오퍼 랜드를 표현할 수 있는 크기가 4비트 밖에 되지 않는다.
- 이 때 오퍼랜드 필드에 메모리 주소를 담는다면 표현할 수 있는 데이터 크기는 메모리 주소 또는 레지스터에 저장할 수 있는 공간만큼 커지게 된다.
- 유효 주소(effective address): 연산의 대상이 되는 데이터가 저장된 위치
- 주소 지정 방식(addressing mode): 연산에 사용할 데이터 위치를 찾는 방법. 유효 주소를 찾게 된다.
    - 현대 CPU는 다양한 주소 지정 방식을 사용함

주소 지정 방식 유형

<데이터를 직접 명시하는 경우>

- 즉시 주소 지정 방식(immediate addressing mode): 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시하는 방식
    - 가장 간단한 형태의 주소 지정 방식이다.
    - 장점: 연산에 사용할 데이터를 직접 명시하기 때문에 아래 주소 지정 방식들보다 속도가 빠르다.
    - 단점: 표현할 수 있는 데이터의 크기가 작아진다.

<메모리에 데이터를 명시하고 메모리 주소를 참조하는 경우>

- 직접 주소 지정 방식(direct addressing mode): 오퍼랜드 필드에 유효 주소를 직접 명시하는 방식
    - 장점: 표현할 수 있는 데이터의 크기가 즉시 주소 지정 방식에 비해 크다.
    - 단점: 표현할 수 있는 유효 주소 수가 여전히 제한적이다.
- 간접 주소 지정 방식(indirect addressing mode): 유효주소의 주소를 오퍼랜드 필드에 명시하는 방식
    - 장점: 직접 주소 지정 방식보다 표현할 수 있는 유효 주소의 범위가 넓어진다.
    - 단점: 데이터를 찾기 위해 메모리 접근을 두번하게 되면서 앞선 방법들보다 속도가 느려진다.

<레지스터에 데이터를 명시하고 레지스터 주소를 참조하는 경우>

- 레지스터 주소 지정 방식(register addressing mode): 데이터를 저장한 레지스터를 오퍼랜드 필드에 직접 명시하는 방식
    - 장점: 직접 주소 지정 방식보다 빠르게 데이터에 접근 가능
    - 단점: 표현할 수 있는 레지스터 크기에 제한이 생길 수 있음
- 레지스터 간접 주소 지정 방식(register indirect addressing mode): 연산에 사용할 데이터는 메모리에 저장하고, 그 주소를 저장한 레지스터를 오퍼랜드 필드에 명시하는 방법
    - 장점: 메모리에 접근하는 횟수가 한번으로 줄어들어 속도가 간접 주소 지정방식보다 빠름

# 주요 Point

- 목적 파일과 실행 파일은 같은 의미를 가지고 있지 않고, 목적 파일이 링킹과정을 거치면 실행파일이 된다.
- 즉시 주소 지정 방식은 “주소”가 저장 되는 것이 아니라 “값”이 저장된다.
- 간접 주소 지정 방식은 주소를 두번 참조하면서 속도면에서 손해를 보게되지만, 직접 주소 지정 방식에 비해 주소 길이가 짧아짐으로 오퍼랜드 필드에 표현할 수 있는 데이터 수가 늘어난다
