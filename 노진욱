https://luxuriant-tibia-a88.notion.site/Chapter2-de3af18c5ac145bea143316b5ebfcb0b?pvs=4
# Chapter2. 데이터

# **요약**

컴퓨터가 데이터를 읽어들이고 이를 이해하고 표현하는 방식에 대해서 학습

# **내용 정리**

### 02-1. 0과 1로 숫자를 표현하는 방법

### (1) 정보 단위

- **비트**(bit): 컴퓨터가 이해하는 가장 작은 정보 단위로 0과 1을 나타낸다.
    - 이후의 정보들은 여러 비트의 조합으로 나타내게 된다.
    - 1비트는 0과 1, 두 가지 정보를 표현할 수 있다.
    - n비트는 2^n의 정보를 표현할 수 있다 (2 * 2 * 2 * .... * 2로 0과 1의 정보 2개를 n군데서 표현할 수 있음).
- **바이트**(byte): 8개의 비트가 묶인 단위이다.
    - 표현할 수 있는 정보량은 2^8 (256)개 이다.
    - 킬로바이트(kB, Kilobyte): 1바이트를 1,000개 묶은 단위
    - 메가바이트(MB, Megabyte): 1킬로바이트를 1,000개 묶은 단위
    - 기가바이트(GB, Gigabyte): 1메가바이트를 1,000개 묶은 단위
    - 테라바이트(TB, Terabyte): 1기가바이트를 1,000개 묶은 단위
    - 이외에도 1,024개를 묶어서 표현한 단위가 있는데, 이는 KiB, MiB, GiB, TiB 등으로 표현된다.
- **워드**(word): CPU가 한번에 처리할 수 있는 데이터 크기를 의미한다.
    - 워드의 크기는 CPU의 종류마다 다른데, 보통 현대 컴퓨터는 32비트 또는 64비트를 처리할 수 있다.
    - 하프 워드(half word): 워드의 절반 크기
    - 풀 워드(full word): 워드의 전체 크기
    - 더블 워드(double word): 워드의 2배 크기
    - 보통 CPU 제조사 인텔 사의 32비트 워드의 CPU는 x86, 64비트 워드의 CPU는 x64로 불린다.

### (2) 이진법

- **십진법**(decimal): 일상적으로 우리가 사용하는 수체계로 0~9의 10개 숫자만으로 모든 수를 표현함
    - 십진수: 십진법으로 표현한 수를 지칭
- **이진법**(binary): 수학에서 0과 1만으로 모든 숫자를 표현하는 방법
    - 이진수: 이진법으로 표현한 수를 지칭함
- 이진수의 사용법
    - 컴퓨터는 0과 1밖에 알지 못하기 때문에 컴퓨터는 데이터를 이진수로 처리한다.
    - 이진수는 을 한다. 즉, 십진법을 이진법으로 표현하면 아래와 같다.
        
        해당 자리수가 1을 넘어가면 자리 올림
        
        - 0 -> 0(2)
        - 1 -> 1(2)
        - 2 -> 10(2)
        - 3 -> 11(2)
        - 4 -> 100(2)
        - ...
    - 위처럼 십진수와 이진수는 구분이 어렵기 때문에 혼동을 예방하기 위해 아래의 방법으로 표기한다.
        - 수학적으로 표기 시: 1000(2)
        - 컴퓨터에서 표현 시: 0b1000

### (3) 이진수의 음수 표현

- 컴퓨터는 0과 1만 이해할 수 있기 때문에 마이너스 부호를 사용하지 않고, 0과 1만으로 음수를 표현해야 한다.
- 보통 2의 보수(two's complement)를 구해 이 값을 음수로 간주한다.
    - 어떤 **이진수의 2의 보수**는 "모든 0과 1을 뒤집고, 거기에 1을 더한 값"으로 구할 수 있다.
    - ex> 이진수 1011(2)의 2의 보수는 다음과 같이 구한다.
        1. 0과 1을 뒤집는다: 0100(2)
        2. 1을 더한다: 0101(2)
    - 실제로 2의 보수가 음수인지 확인하기 위해서는 2의 보수를 두 번 구해보면 된다. -(-B) = B가 되는 원리이다.
        1. 위에서 구한 2의 보수 0101(2)의 2의 보수는 다음과 같다.
        2. 1010(2) -> 1011(2)
        3. 즉, 처음 이진수 값과 동일하게 나타난다.
- 단순히 0과 1을 뒤집는 **1의 보수(one's complement)**도 사용될 수 있으나 2의 보수에 비해 한계가 명확하다.
- 한편 음수를 나타내기 위해 2의보수 처리한 이진수와 일반 이진수의 값이 같을 때 문제가 생길 수 있다.
    - 예를 들어, 1011(2)의 음수는 2의 보수로 0101(2)로 표현되는데, 십진수 5의 이진수도 0101(2)로 표현된다. 이를 어떻게 구분할 것인가? ==> 플래그를 통해 해결
    - **플래그(flag)**: 어떤 수가 양수인지 음수인지를 구분하는 부가정보
- 하지만 2의 보수로 음수를 표현하는 것도 한계가 존재한다.
    1. 0을 음수로 표현할 시 문제가 발생
        - 2^3 공간에서 0을 음수로 표현하면 0000(2)인데, 이를 2의보수 처리하면 10000(2)이 된다.
        - 이를 해결하기 위해 보통 공간을 넘어선 자리올림이 발생하면 해당 자리수는 버리게 된다. 따라서 0000(2)으로 표현은 가능하다.
        - 또한 값이 0인지를 나타내는 플래그를 통해 0의 여부를 판단하기도 한다.
    2. 2^n을 음수로 표현할 시 문제가 발생
        - 2^n은 보수를 취하면 자기 자신이 되어버리는 문제가 발생한다.
        - 예를 들어, 2^3 공간에서 1000(2)를 2의보수 취하면 다시 1000(2)가 돼버린다.
        - 따라서 n비트로는 -2^n **+ 1** ~ 2^n까지 표현이 가능하다. 즉, -2^n은 표현이 불가능하다.

### (4) 십육진법

- 이진법의 특징
    - 장점: 이진법으로 숫자를 표현하면 컴퓨터가 이해하는 숫자정보를 직접적으로 표현할 수 있다.
    - 단점: 0과 1만으로 모든 숫자를 표현하니 숫자의 길이가 너무 길어진다.
- **십육진법**(hexadecimal): 수가 15를 넘어가는 시점에 자리 올림을 하는 숫자 표현 방식
    - 십진수 10, 11, 12, 13, 14, 15는 각각 된다.
        
        A, B, C, D, E, F로 표기
        
    - 하드웨어 관련 개발 분야에서는 십육진수를 직접 쓰는 경우가 있다.
- 십육진법의 표기법: 십진수 15를 표기할 때
    - 수학적 표기: F(16)
    - 코드상 표기: 0xF
- 특히  주로 사용된다.
    
    십육진법은 이진수와의 변환이 쉽고 자유로워
    

!https://blog.kakaocdn.net/dn/phe4B/btrO00Dpx5P/oLzecUu2giSSPo2wXH5gf1/img.png

십육진수를 이진수로 변환

- 십육진수를 이진수로 변환
    - 십육진수 숫자 하나는 이진수 4개의 정보를 가지고 있다 (2^4). 따라서 십육진수 숫자 하나는 4비트로 표현될 수 있다.
    - 따라서 십육진수 하나를 4비트의 이진수로 간주하여 십육진수의 각 숫자를 4개의 비트를 가진 이진수로 각각 변환하고, 변환된 비트들을 이어붙이면 된다.

!https://blog.kakaocdn.net/dn/n6CfX/btrO0Hc11lN/14TPtLsC7KWCSIwS7EmxaK/img.png

이진수를 십육진수로 변환

- 이진수를 십육진수로 변환
    - 마찬가지로 이진수의 숫자 4개는 십육진수 숫자 1개로 변환이 가능하다.
    - 따라서 이진수 숫자를 4개씩 각각 끊고, 이를 십육진수로 변환한 뒤 이어 붙이면 된다.

### 02-2. 0과 1로 문자를 표현하는 방법

### (1) 문자 집합과 인코딩

- **문자 집합**(character set): 컴퓨터가 인식하고 표현할 수 있는 문자 모음
    - 컴퓨터는 문자 집합에 속해있는 문자만 이해할 수 있다.
    - 또한 문자 집합에 속한 문자는 0과 1로 변환되어야 컴퓨터가 이해할 수 있다.
- **문자 인코딩**(character encoding): 문자를 0과 1로 변환하는 과정
    - 같은 문자집합에 대해서도 다양한 인코딩이 존재한다.
    - 보통 문자에 고유한 값을 부여해서 인코딩함. 이를 코드 포인트(code point)라고 함
- **문자 디코딩**(character decoding): 0과 1로 이루어진 문자 코드를 사람이 이해할 수 있는 문자로 변환하는 과정
    - 인코딩의 반대과정이라 볼 수 있다.

### (2) 아스키 코드

- **아스키**(ASCII, American Standard Code for Information Interchange)
    - 초창기 문자 집합
    - 영어 알파벳과 아라비아 숫자, 그리고 일부 특수 문자를 표현함
    - 아스키 문자는 7비트로 표현됨. 즉, 2^7가지를 표현할 수 있어 총 128가지 문자를 표현함
    - 문자 표현 7비트 외에 오류 검출에 사용되는 패리티 비트(parity bit)가 1비트 사용됨
    - 즉 아스키 코드(1byte) = 패리티 (1bit) + 문자 (7bit) 임
- 각 아스키 문자는 0부터 127까지의 숫자 중 하나와 일대일 대응됨
- **아스키 코드**(ascii code): 각 아스키 문자에 대응되는 고유한 수
    - 아스키 코드표: 문자와 아스키 코드 관계를 나타낸 표
    - 아스키 코드는 Backspace, Escape, Cancel, Space 같은 한다.
        
        제어 문자들도 포함
        

<아스키코드의 장단점>

- 장점: 아스키 코드는 매우 간단하게 인코딩 된다.
- 단점: 127가지 문자 외의 다른 문자(한글, 특수문자, 한자 등)는 표현할 수 없다.
- 확장 아스키(Extended ASCII): 아스키코드에 1비트를 추가해 더 다양한 문자가 표현 가능한 인코딩 방식
    - 하지만 문자 표현 가능 수는 256개로 여전히 적다.

### (3) EUC-KR

- **한글 인코딩 방식**: 완성형, 조합형
    - 완성형 인코딩 방식(한글 완성형 코딩): 초성, 중성, 종성이 조합된 완성 글자 자체에 고유한 코드를 부여하는 방식
    - 조합형 인코딩 방식(한글 조합형 코딩): 초성, 중성, 종성 각각을 위한 비트열을 할당해 그것들의 조합으로 완성 글자를 표현하는 인코딩 방식
        - 초성, 중성, 종성에 해당하는 코드를 합하여 하나의 글자 코드를 만들게 된다.
- **EUC-KR**: 완성형 인코딩 방식으로 인코딩 크기는 2바이트(16비트) 이다.
    - 즉, 16진수(4비트) 4개로 표현될 수 있다.
    - 2,350개의 한글 단어를 표현할 수 있지만, 문자 집합에 정의되지 못하는 한글이 있다.
        - ex> 쀍, 쀓 등
- **CP949**: 마이크로소프트에서 개발한 인코딩 방식으로 EUC-KR의 확장 버전
    - 장점: EUC-KR에서 인코딩할 수 없는 문자들을 표현할 수 있다.
    - 단점: 여전히 한글 전체를 표현하진 못한다.

### (4) 유니코드와 UTF-8

- **유니코드**(unicode): 대부분 나라의 문자와 특수문자, 화살표, 이모티콘을 코드로 표현할 수 있는 표준 문자 집합
    - 현대 문자를 표현할 때 가장 많이 사용되는 표준 문자 집합
    - 문자 인코딩에서 매우 중요한 역할을 맡고 있다.
    - 유니코드 부여값 앞에 U+라는 문자가 붙기도 하는데, 십육진수로 유니코드가 표시됐을 때 사용하는 표기이다 (ex> U+D55C, U+AE00 등)
- 유니코드는 문자마다 값이 부여되는데, 이 값을 다양한 방법으로 인코딩한다.
    - 예를 들어, "한"이라는 글자는 16비트로 D55C(16)로 표현된다. 여기서 이 값은 다양한 방법을 통해서 인코딩 된다.
    - 인코딩 방법에는 UTF-8, UTF-16, UTF-32 등이 존재하며, 각 방법마다 인코딩 방식이 다르다.
    - UTF(Unicode Transformation Format): 유니코드를 인코딩 하는 방법
- **UTF-8**: 유니코드를 인코딩하는 방식 중 하나
    - 유니코드 문자에 부여된 값에 따라 인코딩 크기는 1바이트 ~ 4바이트로 달라지게 된다.
    - 즉, 문자의 고유값이 속한 범위에 따라 인코딩 크기가 달라지게 된다.

!https://blog.kakaocdn.net/dn/Iv3I3/btrOQvYoJsn/pp7v6Xqhl9PBM4tCYqMCn1/img.png

문자의 유니코드 고유값에 따라 인코딩 크기가 달라진다.

- 문자값 범위
    - 유니코드 문자에 부여된 값이 0부터 007F(16) 사이일 때는 1바이트로 인코딩됨
    - 유니코드 문자에 부여된 값이 0080(16)부터 07FF(16) 사이일 때는 2바이트로 인코딩됨
    - 유니코드 문자에 부여된 값이 0800(16)부터 FFFF(16) 사이일 때는 3바이트로 인코딩됨
    - 유니코드 문자에 부여된 값이 10000(16)부터 10FFFF(16) 사이일 때는 4바이트로 인코딩
- "한글"을 UTF-8로 인코딩하면?
    - "한"의 유니코드 고윳값은 D55C(16), "글"은 AE00(16)
    - 두 글자 모두 0800(16)과 FFFF(16)사이에 위치함으로 두 글자 각각 3바이트로 인코딩된다.
    - 3바이트로 인코딩 시, 1110XXXX 10XXXXXX 10XXXXXX 로 인코딩된다.
    - 여기서 D55C(16)의 이진수는 1101 0101 0101 1100(2)이며, AE00(16)의 이진수는 1010 1110 0000 0000(2)이다.
    - 위 이진수 값들을 각각 X 부분에 넣어주면 인코딩한 값을 구할 수 있다.
    - 한: 11101101 10010101 10011100(2)
    - 글: 11101010 10111000 10000000(2)

# 참고

- 수의 연산에서 2의 보수를 왜 사용하는지 아래의 사이트들을 추가로 참고.
    - [2진수의 수와 음수 표현법 [1의 보수와 2의 보수]](https://st-lab.tistory.com/189)
    - [[프로그래밍] 2의 보수 구하기, 왜 2의 보수는 음수인가?](https://life-with-coding.tistory.com/298)
- 위 두사이트를 요약하자면 계산의 효율성을 위해 보수 체계를 사용해 음수를 표현하였다. 또한 1의 보수는 2의 보수에 비해 한계가 명확하다.
    - 1의 보수로 처리 시 +0과 -0의 표현 값이 달라지게 되는 문제가 생긴다.

# 학습 후기

- 보통 2^10 단위(1,024)의 증가마다 KB, MB, GB단위가 바뀐다고 이해했었는데, 실제로는 1,000단위의 변경마다 단위가 바뀐다.
    - 2^10 단위마다 바뀌는 단위는 KiB, MiB, GiB 단위이다.
- CPU 처리 단위가 x32, x86가 있는 것은 알고 있었는데, 이를 워드라고 부르는 것은 처음 알았다. 32비트 워드, 64비트 워드 CPU 등으로 불린다.
- 2진법은 앞에 0b, 16진법은 앞에 0x 가 붙는다는 것에 대해 좀 더 명확히 알게 되었다.
- 유니코드는 각 글자마다 부여된 위치(고유값)이고, 이를 인코딩하는 방식이 UTF-8, UTF-16, UTF-32 등으로 나뉜다.
    - 유니코드의 위치(고유값)에 따라서 인코딩된 문자의 크기가 다르다 (UTF-8 기준 1~4 bytes로 차이남).
