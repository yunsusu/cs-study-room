노션 페이지
- https://luxuriant-tibia-a88.notion.site/Chapter4-CPU-68b07aa8b8b143dc902b890dd9eed7e9?pvs=4

### 04-1. ALU와 제어장치

배경 지식

- CPU: 저장된 명령어를 읽고, 해석하고, 실행하는 장치

CPU 내부는 아래 장치들로 구성된다.

- ALU: CPU내에서 계산을 담당
- 제어장치: 명령어를 읽고 해석하는 장치
- 레지스터: CPU 내에 있는 작은 임시 저장 장치

ALU

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/02b3a4f2-2b22-4e4f-a9fe-0014c48f0d5b/1554f85c-9715-4839-af5b-36937ef45fb4/Untitled.png)

- **ALU는 레지스터로부터 피연산자를 받아들이고, 제어장치로부터 제어 신호를 받아들인다.**

### ALU: 계산을 수행하는 장치

- 레지스터에 저장된 피연산자를 받아들임
- 제어장치에서 수행할 연산을 알려주는 제어 신호를 받아들임
- 피연산자와 제어 신호를 통해 산술 연산, 논리 연산 등 다양한 연산을 수행함
- 연산을 위해 여러 회로들이 존재하며, 가산기, 보수기, 시프터, 오버플로우 검출기 등이 존재함

### ALU 회로

- 가산기: 덧셈을 위한 회로
- 보수기: 뺄셈을 위한 회로
- 시프터: 시프트 연산을 수행하는 회로
- 오버플로우 검출기: 오버플로우를 대비한 회로

### ALU가 내보내는 정보

- ALU가 연산을 수행한 결과값은 특정 숫자나 문자, 메모리 주소 등이 될 수 있음
- 결과는 빠른 접근 속도를 위해 일시적으로 레지스터에 저장함
- 플래그: ALU가 연산 결과와 함께 내보내는 추가 정보
    - CPU가 프로그램을 실행할 때 참고해야하는 정보로 플래그 레지스터에 저장됨

### ALU가 내보내는 대표적인 플래그

| 플래그 | 조건 | 내용 (1일 경우 true, 0일 경우 false) |
| --- | --- | --- |
| 부호 플래그 | 연산 결과 < 0 | 1일 경우 계산 결과가 음수, 0일 경우 양수 |
| 제로 플래그 | 연산 결과 == 0 | 1일 경우 계산 결과가 0, 0일 경우 0이 아님 |
| 캐리 플래그 | 연산 결과에 올림수나 빌림수 발생 여부 | 1일 경우 발생, 0일 경우 발생하지 않음 |
| 오버플로우 플래그 | 오버플로우 발생 여부 | 1일 경우 발생, 0일 경우 발생하지 않음 |
| 인터럽트 플래그 | 인터럽트 가능 여부 | 1일 경우 인터럽트 가능, 0일 경우 불가능 |
| 슈퍼바이저 플래그 | 현재 실행중인 모드의 커널 모드 판단 | 1일 경우 커널 모드, 0일 경우 커널 모드가 아님 (사용자 모드) |

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/02b3a4f2-2b22-4e4f-a9fe-0014c48f0d5b/a4d80efb-bef1-476c-97e8-14a209255acd/Untitled.png)

# 제어장치

!https://blog.kakaocdn.net/dn/1LOOh/btrPQfOE730/R6cMybYqK9Kk6FqBSWCXLk/img.png

- 제어 신호를 내보내고 명령어를 해석하는 부품
- 제어 장치는 컴퓨터 부품들을 관리하고 작동시키는데 사용되는 전기 신호인 제어 신호를 내보냄
- 제어장치는 CPU 구성 요소 중 가장 정교하게 설계된 부품이라 할 수 있고, 제조사마다 제어장치 설계에 차이가 있다.

### 제어 장치가 받아들이는 정보

**1. 클럭 신호를 받아 들임**

- 클럭(clock): 컴퓨터의 시간 단위로 부품들은 클럭 주기에 맞춰 명령어, 연산 등이 처리된다.

**2. 해석해야할 명령어를 받아 들임**

- 명령어 레지스터로 부터 명령어를 받아들이고, 해석해 제어 신호를 발생시킨다.
- 발생된 제어 신호는 각 컴퓨터 부품들이 해야 할 내용들을 전기 신호로 담고 있다.

**3. 플래그 레지스터 속 플래그 값을 받아 들임**

- 플래그 값들을 참고해서 제어신호를 발생시킴

**4. 시스템 버스의 제어 버스를 통해 제어 신호를 받아들임**

- 이 때 제어 신호는 입출력 장치를 포함한 CPU 외부 장치에서 발생한 제어 신호임

### 제어장치가 내보내는 정보

**1. CPU 외부에 전달하는 제어 신호**

- 제어 버스로 제어 신호를 내보내게 됨
- 메모리에 전달하는 제어 신호와 입출력 장치에 전달하는 제어신호 등이 있음

**2. CPU 내부에 전달하는 제어 신호**

- ALU에 전달하는 제어신호와 레지스터에 전달하는 제어신호 등이 있음

각 제어신호는 부품들의 역할에 맞는 역할을 수행하는 명령을 담고 있음

# 4-2. 레지스터

레지스터는 CPU 내부의 작은 임시저장장치로, 프로그램 속 명령어를 저장하거나 연산에 사용되는 데이터를 저장한다.

## 반드시 알아야 할 레지스터

1. 프로그램 카운터(Program Counter, PC)

- 명령어가 저장된 주소를 저장함
- 명령어 포인터(Instruction Pointer, IP)라고도 불림

2. 명령어 레지스터(Instruction Register, IR)

- 명령어를 저장함
- 즉, 프로그램 카운터에 지정된 위치의 명령어를 저장하는 레지스터
- 제어장치는 명령어 레지스터 속 명령어를 읽고 해석해서 제어 신호를 발생시키게 됨

3. 메모리 주소 레지스터(Memory Address Register, MAR)

- 메모리의 주소를 저장하는 레지스터
- 주소 값이 주소 버스를 통해 CPU에 오갈 때 메모리 주소 레지스터를 거침

4. 메모리 버퍼 레지스터(Memory Buffer Register)

- 메모리와 주고받을 데이터와 명령어를 저장하는 레지스터
- 메모리 데이터 레지스터(Memory Data Register, MDR)이라고도 불림

5. 범용 레지스터(General Purpose Register)

- 일반적으로 자유롭게 사용할 수 있는 레지스터
- 여러 값(데이터, 주소 등)을 모두 젖아할 수 있음
- 일반적으로 CPU 내에는 여러 개의 범용 레지스터가 존재

6. 플래그 레지스터(Flag Register)

- 연산 결과나 CPU 상태의 부가적 정보를 저장하는 레지스터

프로그램을 실행하는 과정을 통해 살펴보는 레지스터의 동작 원리

!https://blog.kakaocdn.net/dn/bBhvQc/btrPQMZAjhd/eBWLfKHPxWtwz4qORbanG1/img.png

### CPU 내 장치와 레지스터, 시스템 버스, 메모리 구조도

(1) 프로그램이 메모리에 위치한 처음 주소가 프로그램 카운터에 저장된다.

(2) 프로그램 카운터의 주소가 메모리 주소 레지스터에 전달된다.

(3) 메모리 주소 레지스터는 주소 버스를 통해, 메모리 읽기라는 제어 신호는 제어 버스를 통해 메모리에 전달된다.

(4) 메모리는 해당 위치에 저장된 값을 데이터 버스를 통해 메모리 버퍼 레지스터로 전달한다. 그리고 프로그램 카운터는 다음 데이터가 저장된 주소로 갱신된다.

(5) 메모리 버퍼 레지스터에 저장된 값은 명령어 레지스터로 이동된다.

(6) 제어장치는 명령어 레지스터에 있는 명령어를 해석하고 제어 신호를 발생시킨다.

(7) 위 과정을 반복하며 CPU는 프로그램에 저장된 다음 명령어들을 계속해서 처리해나간다.

## **레지스터 주소 지정 방식**

### 1. 스택 주소 지정 방식

!https://blog.kakaocdn.net/dn/btXceZ/btrPRARWenf/pcc6ujGBIlrFq3MNNTSaFk/img.png

- 스택 주소 지정 방식: 스택과 스택 포인터를 이용한 주소 지정 방식
- 스택 포인터(stack pointer): 스택 주소 지정 방식에 사용되는 레지스터로 스택의 꼭대기를 가르킴
    - 마지막에 저장한 값의 위치를 저장하고 있는 레지스터다.
    - 스택의 어디까지 데이터가 채워져 있는지를 나타냄
- 스택 영역: 메모리 내 스택처럼 사용하기로 정해진 공간들
    - 다른 주소 공간과는 분리돼 스택처럼 사용하는 영역이다.

### 2. 변위 주소 지정 방식

!https://blog.kakaocdn.net/dn/cKWMXn/btrPWUBQ5bU/VgWLkgBnyfF0zEjcA7JQK1/img.png

- 변위 주소 지정 방식(displacement addressing mode): 오퍼랜드 필드 값 (변위)과 특정 레지스터 값을 더해서 유효 주소를 얻어내는 주소 방식
- 변위 주소 지정 방식을 사용하는 명령어는 연산 코드 필드, 레지스터 필드, 오퍼랜드 필드로 나뉜다.
    - 연산 코드 필드: 수행할 연산 내용이 담긴 필드
    - 레지스터 필드: 더할 값을 담고 있는 필드
    - 오퍼랜드 필드: 주소를 담고 있는 필드
- 오퍼랜드 필드 주소에 어떤 레지스터를 더하는지에 따라 다음과 같이 나뉜다.
    - 상대 주소 지정 방식
    - 베이스 레지스터 주소 지정 방식
    - CPU 종류에 따라 이외에도 다양한 방식들이 존재한다.

### 2-1. 상대 주소 지정 방식

!https://blog.kakaocdn.net/dn/sDC6F/btrPXup0cEr/hiZ2AZppbmNkagviGUX5Xk/img.png

- 상대 주소 지정 방식(relative addressing mode): 오퍼랜드와 프로그램 카운터 값을 더해 유효 주소 값을 얻는 방식
    - 프로그램 카운터는 읽어들일 명령어 주소를 가지고 있음
    - 여기서 오퍼랜드 값 (k라고 가정) 이 더해지면서 읽어들일 주소에서 k만큼 떨어진 주소의 명령어를 실행함
    - 분기하여서 특정 주소의 코드를 실행할 때 사용하게 됨 (프로그래밍에서 if문을 생각)

### 2-2. 베이스 레지스터 주소 지정 방식

!https://blog.kakaocdn.net/dn/bvEAOD/btrPQI4qsrV/RIIIEkovmtTrgYpR25sl0K/img.png

- 베이스 레지스터 주소 지정 방식(base-register addressing mode): 오퍼랜드와 베이스 레지스터 값을 더해서 유효 주소를 얻는 방식
    - 베이스 레지스터는 **"기준 주소"**, 오퍼랜드는 **"기준 주소로부터 떨어진 거리"**의 역할을 함
    - 베이스 레지스터 속 기준 주소로부터 오퍼랜드 값만큼 떨어진 거리의 주소 값을 유효주소로 선택하는 방식

# 04-3. 명령어 사이클과 인터럽트

- 명령어 사이클
    - 하나의 명령어를 처리하는 정형화된 흐름
- 인터럽트
    - CPU의 명령어 처리 과정의 흐름을 끊는 상황

### 명령어 사이클

- 명령어 사이클(instruction cycle): 프로그램 속 명령어들이 실행되는 주기
    - 프로그램 속 명령어들은 명령어 사이클이 반복되며 실행됨
    - 프로그램의 명령어들은 일반적으로 인출과 실행 사이클이 반복되며 실행된다.
    - 간접 사이클이 추가되는 경우도 있다.
- 인출 사이클(fetch cycle): 메모리에 있는 명령어를 CPU로 가져오는 단계
    - 위 레지스터 동작 원리의 (1) ~ (5) 단계
- 실행 사이클(excution cylce): CPU로 가져온 명령어를 실행하는 단계
    - 제어 장치가 명령어 레지스터의 값을 해석하고, 제어 신호를 발생시키는 과정
- 간접 사이클(instruction cylce): 명령어를 실행하기 위해 메모리 접근을 한번 더 하는 과정
    - 간접 주소 지정 방식인 경우 유효 주소의 주소에 접근하기 위해 메모리 접근이 한번 더 필요하다.

### 인터럽트

- 인터럽트(interrupt): CPU의 작업을 방해하는 신호
    - CPU가 처리할 다른 작업이 생길 때 발생함
    - 우선순위가 존재함
    - 동기 인터럽트와 비동기 인터럽트가 존재함
- 동기 인터럽트(synchronous interrupts): CPU에 의해 발생하는 인터럽트
    - CPU가 명령어를 수행하면서 예상치 못한 상황이 생겼을 때 발생
    - 예외(exception)이라고도 불림
- 비동기 인터럽트(asynchronous interrupt): 입출력장치에서 발생하는 인터럽트
    - 키보드, 마우스 등의 입력이나 프린터의 작업 완료 등으로 발생
    - 입출력 작업 발생 시 나타남
    - 일반적인 인터럽트이며, 하드웨어 인터럽트 라고도 불림
    - 인터럽트 발생으로 입출력 작업 결과를 확인하여 CPU의 생산 효율을 높임

### 하드웨어 인터럽트 처리 순서

(1) 입출력장치는 CPU에 인터럽트 요청 신호를 보냄

(2) CPU는 실행 사이클 종료 후 명령어를 인출하기 전에 인터럽트 여부를 확인함

(3) CPU는 인터럽트 요청이 존재할 시 인터럽트 플래그 상태를 통해 인터럽트를 수용할 수 있는지를 체크함

(4) 인터럽트 수용이 가능하면 CPU는 지금까지 작업 내용을 백업함

(5) CPU는 인터럽트 벡터를 참조해 인터럽트 서비스 루틴을 실행함

(6) 인터럽트 서비스 루틴 종료 후, (4)에서 백업한 작업을 복구해 다시 실행함

용어 정리

- 인터럽트 요청 신호: 입출력 장치에서 CPU에 인터럽트를 요청하는 신호
- 인터럽트 플래그(interrupt flag): 하드웨어 인터럽트를 수용할지 여부를 결정하는 플래그
    - CPU가 인터럽트 요청을 받아들이려면 인터럽트 플래그가 활성화 돼 있어야 함
    - CPU가 중요 작업을 처리 중이거나 방해 신호를 받지 않을 때는 0으로 설정되며, 이때는 인터럽트 요청을 무시함
    - 정전이나 하드웨어 고장으로 발생하는 인터럽트는 플래그가 0이더라도 CPU가 요청을 무시할 수 없다.
    - 플래그가 인터럽트 요청을 막을 수 있는 인터럽트인지 여부에 따라 막을 수 있는 인터럽트(maskable interrupt)와 막을 수 없는 인터럽트(non maskable interrupt)로 나뉜다.
- 인터럽트 서비스 루틴(interrupt Service Routine, ISR): 인터럽트를 처리하는 프로그램
    - 인터럽트 발생 시 해당 인터럽트를 어떻게 처리하고 작동해야 할지에 대한 정보를 가지고 있다.
    - 인터럽트 핸들러(interrupt handler)라고도 불림

### 인터럽트 서비스 루틴 발생 과정

!https://blog.kakaocdn.net/dn/bb0iiz/btrPU0Qjevp/UBnkkpgFUKcqcDLj0MdSFK/img.png

- 인터럽트 벡터(interrupt vector): 인터럽트 서비스 루틴을 식별하는 정보
    - 수많은 인터럽트 서비스 루틴을 구분하는 정보이다.
    - CPU는 인터럽트 벡터를 통해 인터럽트 서비스 루틴의 시작 주소를 알 수 있다.
    - CPU는 하드웨어 인터럽트 요청을 보낸 대상으로부터 인터럽트 벡터를 데이터 버스를 통해 전달받는다.

### 인터럽트 백업 과정

- 인터럽트가 발생하면 실행 중이던 작업 내역은 스택에 백업하게 됨
    - 프로그램 카운터 등 프로그램 재실행에 필요한 모든 정보를 저장
    - 인터럽트 서비스 루틴이 끝나면 스택 영역으로 돌아와 작업을 재개

### 예외의 종류

- 폴트(fault): 예외 처리 후, 예외가 발생한 명령어부터 다시 실행하는 예외
- 트랩(trap): 예외 처리 후, 예외 발생 다음 명령어부터 실행하는 예외
    - 주로 디버깅할 때 사용한다.
    - 특정 코드가 실행되는 순간을 출력(디버깅) 후 다시 재개할 때는 다음 코드부터 실행하면 된다.
- 중단(abort): CPU가 실행 중인 프로그램을 강제로 중단시켜야 하는 심각한 오류를 발견했을 때 발생하는 예외
- 소프트웨어 인터럽트(software interrupt): 시스템 호출이 발생했을 때 나타나는 예외

# 참조

- ALU와 레지스터, 제어장치의 각 역할 : https://m.blog.naver.com/PostView.naver?blogId=makeflood&logNo=222413482401&proxyReferer=https:%2F%2Fwww.google.com%2F
- 연산이 처리되는 과정과 메모리 주소 레지스터가 왜 존재하는 지 - [https://velog.io/@taeil314/컴퓨터의-작동-원리](https://velog.io/@taeil314/%EC%BB%B4%ED%93%A8%ED%84%B0%EC%9D%98-%EC%9E%91%EB%8F%99-%EC%9B%90%EB%A6%AC)
- [https://velog.io/@ckstn0777/컴퓨터구조-9htxi9jo](https://velog.io/@ckstn0777/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-9htxi9jo) (+ 명령어 사이클)

# 주요 Point

- 상용화된 CPU는 이론으로 배운 모습과 크게 다를 수 있다.
    - CPU 제조사마다 레지스터 이름이 다르고 역할이 다르다.
    - 상용화된 실제 CPU의 레지스터를 살펴볼 필요가 있다.
- 명령어 사이클 = 인출 사이클 + 실행 사이클 + 간접 사이클 + 인터럽트 사이클
- Fetch Cycle : 115p 02 ~ 06 단계
- 인터럽트 플래그가 False더라도 인터럽트를 시킬 수 있는 긴급한 인터럽트가 있을 수 있다.
- 예외에는 fault와 trap이 있고, fault와 trap의 차이점을 잘 파악해야 한다.
